<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Image Format Converter — Pro (Browser-only)</title>
    <meta name="description" content="Convert images in your browser: PNG/JPEG/WebP/AVIF, resize, crop, watermark, enhance, EXIF passthrough." />
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Cpath fill='%23000' d='M2 2h12v12H2z'/%3E%3C/svg%3E" />
    <script src="https://cdn.tailwindcss.com"></script>
    <script> tailwind.config = { darkMode: 'class' } </script>
    <style> html, body, #root { height: 100%; } </style>
  </head>
  <body class="antialiased">
    <div id="root">
      <div class="p-6 max-w-xl mx-auto">
        <p class="text-sm opacity-70">Loading… If it doesn’t load, your network may block certain CDNs. This build auto-falls back.</p>
      </div>
    </div>

    <script type="module">
      // --- Pick a working CDN (jsDelivr -> unpkg) and the right module suffix for each ---
      const CDNS = [
        { base: "https://cdn.jsdelivr.net/npm", esm: "+esm" },
        { base: "https://unpkg.com", esm: "?module" },
      ];

      async function chooseCDN() {
        for (const c of CDNS) {
          try {
            await import(`${c.base}/react@18.3.1/${c.esm}`);
            return c;
          } catch (e) {
            // try next
          }
        }
        throw new Error("No CDN reachable for ESM modules.");
      }

      const CDN = await chooseCDN();

      // Import everything using the chosen CDN + suffix
      const [
        ReactPkg,
        ReactDOMClientPkg,
        MotionPkg,
        LucidePkg,
        JSZip,
        FileSaver,
        ReactEasyCrop,
        piexif,
      ] = await Promise.all([
        import(`${CDN.base}/react@18.3.1/${CDN.esm}`),
        import(`${CDN.base}/react-dom@18.3.1/client/${CDN.esm}`),
        import(`${CDN.base}/framer-motion@11.3.30/${CDN.esm}`),
        import(`${CDN.base}/lucide-react@0.471.1/${CDN.esm}`),
        import(`${CDN.base}/jszip@3.10.1/${CDN.esm}`),
        import(`${CDN.base}/file-saver@2.0.5/${CDN.esm}`),
        import(`${CDN.base}/react-easy-crop@5.0.7/${CDN.esm}`),
        import(`${CDN.base}/piexifjs@1.0.6/${CDN.esm}`),
      ]);

      const React = ReactPkg.default ?? ReactPkg;
      const { createRoot } = ReactDOMClientPkg;
      const { motion, AnimatePresence } = MotionPkg;
      const {
        Upload, Download, Image: ImageIcon, Trash2, FlipHorizontal, FlipVertical,
        Settings2, Sun, Moon, Layers, Type, ImagePlus, Wand2
      } = LucidePkg;
      const Cropper = ReactEasyCrop.default ?? ReactEasyCrop;

      const { useEffect, useMemo, useRef, useState } = React;
      const { saveAs } = FileSaver;

      // ---------- Helpers ----------
      async function getImageDimensions(url) { const img = await loadHTMLImage(url); return { w: img.naturalWidth, h: img.naturalHeight }; }
      function loadHTMLImage(url) { return new Promise((resolve, reject) => { const img = new Image(); img.onload = () => resolve(img); img.onerror = reject; img.crossOrigin = "anonymous"; img.src = url; }); }
      function hasSolidBg(hex) { return typeof hex === "string" && hex.length >= 7 && hex.length !== 9; }
      function placeRect(w, h, cw, ch, pos, m) {
        let x=0, y=0; // y = text baseline
        switch(pos){
          case "top-left": x=m; y=m+h; break;
          case "top-right": x=cw-m-w; y=m+h; break;
          case "bottom-left": x=m; y=ch-m; break;
          case "center": x=(cw-w)/2; y=(ch+h)/2; break;
          default: x=cw-m-w; y=ch-m; // bottom-right
        }
        return { x, y };
      }
      function evalAspect(s){ const map={"1:1":1, "4:3":4/3, "16:9":16/9, "9:16":9/16}; return map[s]??undefined; }
      function clamp(v){ return Math.max(0, Math.min(255, v|0)); }
      function unsharpMask(data, w, h, amt){
        if (amt<=0) return data;
        const k = amt;
        const a = new Uint8ClampedArray(data);
        const idx=(x,y)=> (y*w + x)*4;
        const out = new Uint8ClampedArray(data.length);
        for (let y=1;y<h-1;y++){
          for (let x=1;x<w-1;x++){
            for (let c=0;c<3;c++){
              const i = idx(x,y)+c;
              const v = a[idx(x,y)+c]*(1+4*k)
                      - a[idx(x-1,y)+c]*k - a[idx(x+1,y)+c]*k
                      - a[idx(x,y-1)+c]*k - a[idx(x,y+1)+c]*k;
              out[i]=clamp(v);
            }
            out[idx(x,y)+3]=a[idx(x,y)+3];
          }
        }
        for (let x=0;x<w;x++){ for (let c=0;c<4;c++){ out[idx(x,0)+c]=a[idx(x,0)+c]; out[idx(x,h-1)+c]=a[idx(x,h-1)+c]; } }
        for (let y=0;y<h;y++){ for (let c=0;c<4;c++){ out[idx(0,y)+c]=a[idx(0,y)+c]; out[idx(w-1,y)+c]=a[idx(w-1,y)+c]; } }
        return out;
      }
      function blobToDataURL(blob){ return new Promise((res)=>{ const r=new FileReader(); r.onload=()=>res(r.result); r.readAsDataURL(blob); }); }
      function dataURLToBlob(dataURL){ const arr=dataURL.split(','); const mime=arr[0].match(/:(.*?);/)[1]; const bstr=atob(arr[1]); let n=bstr.length; const u8=new Uint8Array(n); while(n--){u8[n]=bstr.charCodeAt(n);} return new Blob([u8], {type:mime}); }

      // ---------- Constants ----------
      const SUPPORTED_OUTPUTS = [
        { label: "PNG", mime: "image/png", id: "png", lossy: false },
        { label: "JPEG", mime: "image/jpeg", id: "jpeg", lossy: true },
        { label: "WebP", mime: "image/webp", id: "webp", lossy: true },
        { label: "AVIF", mime: "image/avif", id: "avif", lossy: true },
      ];
      const ACCEPTED_INPUTS = [
        "image/png","image/jpeg","image/webp","image/avif","image/gif","image/bmp","image/svg+xml","image/tiff",
      ];
      const SOCIAL_PRESETS = [
        { group: "Instagram", label: "Post 1:1", aspect: 1/1 },
        { group: "Instagram", label: "Portrait 4:5", aspect: 4/5 },
        { group: "Instagram", label: "Story/Reel 9:16", aspect: 9/16 },
        { group: "LinkedIn", label: "Post 1200×627 (~1.91:1)", aspect: 1200/627 },
        { group: "LinkedIn", label: "Square 1:1", aspect: 1/1 },
        { group: "iPhone", label: "iPhone 13 wallpaper 1170×2532 (~9:19.5)", aspect: 9/19.5 },
      ];

      // ---------- Theme hook ----------
      function useColorScheme() {
        const [dark, setDark] = useState(() => {
          if (typeof window === "undefined") return true;
          return window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches;
        });
        useEffect(() => {
          const root = document.documentElement;
          if (dark) root.classList.add("dark"); else root.classList.remove("dark");
        }, [dark]);
        return { dark, setDark };
      }
      function classNames(...arr) { return arr.filter(Boolean).join(" "); }

      // ---------- App ----------
      function App(){
        const { dark, setDark } = useColorScheme();
        const [files, setFiles] = useState([]); // {id, file, url, name, width, height, focalX, focalY, crop?}
        const [targetFormat, setTargetFormat] = useState("webp");
        const [quality, setQuality] = useState(0.92);
        const [resizeMode, setResizeMode] = useState("original"); // original | pixels | percent
        const [targetW, setTargetW] = useState(0);
        const [targetH, setTargetH] = useState(0);
        const [keepAspect, setKeepAspect] = useState(true);
        const [bgColor, setBgColor] = useState("#00000000"); // hex (#RRGGBB or #RRGGBBAA)
        const [rotateDeg, setRotateDeg] = useState(0);
        const [flipH, setFlipH] = useState(false);
        const [flipV, setFlipV] = useState(false);
        const [prefix, setPrefix] = useState("");
        const [suffix, setSuffix] = useState("_converted");
        const [processing, setProcessing] = useState(false);
        const [avifSupported, setAvifSupported] = useState(true);

        // Crop presets & manual crop editor
        const [cropEnabled, setCropEnabled] = useState(false);
        const [cropAspect, setCropAspect] = useState("free"); // free or numeric aspect
        const [presetAspect, setPresetAspect] = useState(null); // number | null
        const [cropperOpen, setCropperOpen] = useState(false);
        const [activeFileId, setActiveFileId] = useState(null);
        const [cropZoom, setCropZoom] = useState(1);
        const [cropPos, setCropPos] = useState({ x: 0, y: 0 });
        const [cropPixels, setCropPixels] = useState(null); // {x,y,width,height}

        // Focal sliders (for auto-crop mode)
        const [focalX, setFocalX] = useState(50);
        const [focalY, setFocalY] = useState(50);

        // Watermark: text
        const [wmText, setWmText] = useState("");
        const [wmOpacity, setWmOpacity] = useState(0.25);
        const [wmSize, setWmSize] = useState(24);
        const [wmPosition, setWmPosition] = useState("bottom-right"); // tl,tr,bl,br,center
        const [wmMargin, setWmMargin] = useState(16);

        // Watermark: image (logo)
        const [logoUrl, setLogoUrl] = useState(null);
        const [logoImg, setLogoImg] = useState(null);
        const [logoOpacity, setLogoOpacity] = useState(0.5);
        const [logoScale, setLogoScale] = useState(12); // % of output width
        const [logoPosition, setLogoPosition] = useState("bottom-right");
        const [logoMargin, setLogoMargin] = useState(16);

        //
